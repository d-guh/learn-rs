# Defining an Enum
Structs give you a way of grouping values, enums give you a way of specifying a set of values.
```rs
enum IpAddrKind {
    V4,
    V6,
}
```
## Enum Values
We can creates instances of the above enum as follows:
```rs
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```
Note the namespace resolution `::`.
This is useful for situations like the following function:
```rs
fn route(ip_kind: IpAddrKind) { /*...*/ }
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```
There's even more advantages of using enums, for example, if you wanted to store data and not just the type, you could use a struct as follows:
```rs
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
```
OR you could use the enum directly:
```rs
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
```
Which makes the situation simpler. This also applies since each variant of an enum can have different types and amounts of data:
```rs
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
```
Specifically for IP addresses, there's also standard library functions for this very purpose that combines struct and enum:
```rs
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
Note that these and our previously defined enum don't conflict, since the std `IpAddr` isn't brought into scope.

Here's another enum example:
```rs
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
This groups all these various types and data together, more effectivley than structs could (shown below):
```rs
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
```
You can also define methods in enums similar to how structs use `impl`:
```rs
    impl Message {
        fn call(&self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
```
The `self` here represents the message value the enum holds.
## The `Option` Enum and Its Advantages Over Null Values
The `Option` enum is part of the standard library that encodes the common scenario of a value being something or nothing. (i.e. first item in a list vs empty list)

Rust is lacking the null feature of other languages (which may not be a bad thing)

The issue with null values is that if you pass a null value to be used as not-null, you will get an error.

The concept being that null is a value that is invalid or absent, the `Option` enum encodes the concept of a vlaue being present or absent:
```rs
enum Option<T> {
    None,
    Some(T),
}
```
This enum is so useful its included in the prelude, and does not need to be brought into scope explicity, (i.e. you can use `Some` and `None` w/o `Option::`)

`<T>` TYPE PARAMS YEAHHHHH`
```rs
    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option<i32> = None;
```
Pretty similar to C++

You can try to do the following, but it will not compile:
```rs
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
```
The issue here is that rust doesn't know how to add `i8` and `Option<i8>`, so we must convert `Option<T>` to `T` before performing `T` operations. This eliminates the risk of incorrectly assuming a not-null value.

Overall, anytime there is a value that could be null, you must opt in by making the type `Option<T>`, and anywhere there isn't `Option<T>` you can assume it isn't null.
