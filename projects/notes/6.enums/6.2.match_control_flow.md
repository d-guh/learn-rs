# The `match` Control Flow Construct
`match` allows you to compare a value against a series of patterns and execute code depending on which pattern matches.
This seems like a switch statement.
```rs
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
`match` can match more types than boolean, so more powerful than `if`.

You don't always have to use curly brackets if the match arm is short, but if multi-line you must:
```rs
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
## Patterns That Bind to Values
Match arms can also bind to parts of values that match a pattern, here's a data structure:
```rs
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```
We can add a variable called state that matches the values of `Coin::Quarter`, when it matches, state will bind to the value of that quarters state, we can then use `state` in the code for the arm:
```rs
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {state:?}!");
            25
        }
    }
}
```
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` would be `Coin::Quarter(UsState::Alaska)`. When we compare that with the match arms, it matches at `Coin::Quarter(state)` and `state` binds to `UsState::Alaska`, which can be used in `println!` to get the inner state value out of `Coin` for `Quarter`.
## Matching with `Option<T>`
You can also match `Option<T>` directly.
```rs
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
```
## Matches Are Exhaustive
`match` must cover all possibilities.

The following will not compile:
```rs
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }

```
Since we didn't cover every case, rust prevents us from forgetting the `None` case.
## Catch-All Patterns and the `_` Placeholder
Here's some silly diceroll logic:
```rs
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
```
For the first two arms, the pattern is literal `3` and `7`, the last arm covers every other value that moves the player. This compiles even though every option isn't listed, since the last arm will match anything not specifically listed.

There's another way to do this using the `_` pattern:
```rs
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
```
This `_` pattern matches any value and does not bind to the value.
