# Method Syntax
Methods are similar to functions, but definited within a struct (or enum/trait) and have the `self` parameter.
## Defining Methods
```rs
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
The `impl` block for `Rectangle` contains the `area` function, which is now a method for `Rectangle`, rather than using `rectangle: &Rectangle` you can use `self: &Self`.
We use `&` to avoid taking ownership but simply read the data in the struct 
```rs
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```
Choosing the memmber `width` here
### Wheres the `->` Operator?
Rust automatically adds `&`, `*`, etc. so the object matches the signature of the method, for example, these are the sames:
```rs
p1.distance(&p2);
(&p1).distance(&p2);
```
## Methods with More Parameters
```rs
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```
Program to check if one rectangle fits in another.
```rs
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```
Segment that uses a struct to implement the checking method.
## Associated Functions
Any functions within `impl` are *associated functions* because they associate with the type after `impl`.
Associated functions that don't have `self` as their first parameter (not a method), because they don't need an instance of the object.
```rs
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```
You can call associated functions with the `::` operator.
## Multiple `impl` Blocks

